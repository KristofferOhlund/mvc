{% extends "base.html.twig" %}
{% block title %}Report{% endblock title %}

{% block main %}
<article>
<div class="about-container">
    <div class="box1">
        <section>
            <h1 id="kmom01">Kmom01</h1>
            <p>Nu är jag igång med kursen mvc! För mig var det en omställning att gå från Python till Php, men det kändes lättare efter att ha gått igenom klasser och objekt i Php. Objektorientering generellt har jag erfarenhet av från tidigare oopython kurs och jag har även gått en kurs i C# vilket gör att jag känner igen begrepp som private, public, instans, typdeklarationer etc.</p>
            <p>
                Grunder man behöver veta för att komma igång är generella begrepp inom objekterientering och klasser. Dels är klasser och objekt "object by reference" vilket gör att vår variabel för en klass pekar på en referens i minnet, om vi därför kör obj2 = obj1 och i obj2->name = "kalle" så ändrar du även på obj1.
                Keyword <code>$this</code> refererar till <code>self</code> i python och pekar på instansen av ett objekt.
                För att initera en instans av en klass behöver vi en constructor, som då även kan ta emot argument.
                Klasser i Php går även att göra <code>encapuslated</code> vilket betyder att vi kan välja vilka metoder och attribug vi vill ska kunna användas utanför klasen. En <code>private</code> attribut eller metod kan bara användas av klassen internt, medan en <code>public</code> kan användas utanför klassen.
            </p>
            <p>
                Om jag ska reflektera över strukturen för uppgiften i report så är den lite delad. Allt är ju väl organiserat med moduler indelat i egna mappar etc. Nackdelen är dock att du får en mängd olika mappar och filer som du inte har någon aning om vad de gör. Utöver Symfonys egna appstruktur så får du även filer för composer och package.json.
                Däremot var övningen vi gjorde inför uppgiften välstrukturerad som vanligt, det var bra exempel och mycket gick att återanvända och anpassa inför uppgiften.
            </p>
            <p>Gällande artikel PHP The Right Way så är det svårt att välja ett specifikt område. Allting ser egentligen intressant ut men om jag ska välja några rubriker som jag finner extra intressanta så är det Security. Det känns som att när vi kan skapa användare och hantera inloggningar m.m så har vi skapat en &quot;riktig&quot; webbapplikation. Till användare och inloggningar hör ju även databaser, något som också är intressant att få grepp om tillsammans med hur vi kan använda det i PHP. Docker känner jag bara igen vid namn så det blir jag också nyfiken på, utan att ha någon som helst tidigare erfarenhet eller kunskap om vad det egentligen är.</p>
            <p>Min TIL för detta kmom är nog främst Symfony, att få lite flyt i arbetet med att skapa Controllers och Templates. Först tyckte jag det kändes rörigt med att visa assets men jag har ändå lyckats visa de bilder jag velat, så det börjar också landa. Utöver det så är det helheten, att kunna följa en krav specifikation och skapa innehåll som matsvarar dem.</p>
        </section>
        <section>
            <h1 id="kmom02">Kmom02</h1>
            <p>
                Nu har vi tittat mer på Objektorientering inom Php. Några konstruktioner vi jobbat med är: </p>
                <ul>
                    <li>
                        <p><strong>Kompositon</strong> Vilket innebär när en klass en starkt koppling till en annan klass. I min egna lösning så har klassen <strong>CardGraphic</strong> en stark koppling till klassen <strong>DeckOfCards</strong> då alla instanser av CardGraphic skapas inuti DeckOfCards. Om vi därför skulle radera vårat objekt av DeckOfCards så försvinner även alla instanser av CardGraphic.</p>
                    </li>
                    <li><p>
                        <strong>Interface</strong> är som ett kontrakt, en blueprint över vilka metoder som ska finnas i en klass. Ett interface har ingen body för sina metoder och beskriver inte hur någonting ska genomföras, bara att de ska genomföras.
                    </p></li>
                    <li><p>
                        <strong>Ett Trait</strong> är som en klass men ändå inte, ett Trait är ett sätt för PHP att jobba med "multiple inheritence". Då en klass i PHP inte kan ärva från flera klasser, men använda sig av flera traits. Ett trait kan definera funktioner och attribut som en klass sedan kan använda sig av, och då båda av en eller flera traits.
                    </p></li>
                </ul>
            
                <p>Jag har <strong>implementerat</strong> uppgiften genom att skapa klasserna enligt UML diagrammet ovan. För varje route kollar jag först om det finns en session, om inte skapar jag först en instans av DeckOfCards, därefter anropar jag metoden generateDeck som skapar 52st CardGraphic obekt, dessa objekt lägger jag sedan tillsammans med några attribut från Card klassen, som stringValue och color (&quot;4&quot;, &quot;hjärter&quot;) och symbol från CardGraphic i en array. Därefter sparar jag mitt DeckOfCards objekt i session, vilket gör att jag kan hämta objektet och använda dess metoder i övriga routes.</p>

                <p>
                    För tillfället är jag <strong>mycket nöjd med min implementation</strong>. Det är svårt att se nu men om man jämför mot mina tidigare commits så ser man att min lösning är ganska annorlunda. Det var först när jag kom till uppgiften API/Json som jag insåg att jag måste strukturera om koden och då främst för hur jag hämtar symboler för varje kort. Detta gör att mitt UML diagram skiljer sig något mot min slutgiltiga implementation.
                </p>
                <p><strong>Reflektioner</strong> såhär långt är att det är smidigt att jobba med applikationskod och symfony enligt MVC. Det är bra struktur och det är skönt att ha olika directories under src/ - en med Controllers och en annan med applikationskod. En annan reflektion är att veckans kmom var väldigt stor och jag hade uppskattat tydligare instruktioner / krav på uppgiften. Jag har i princip aldrig spelat kort och såg därför inte alls hur jag skulle börja eller vad jag ville uppnå.</p>
                <p>Min <strong>TIL</strong> för detta kmom är nog just MVC delen, att skapa applikationskod och sedan Controllers med olika routes för att bygga en applikation. I och med min senaste implementation känner jag även att jag blivit bättre på &quot;kod-design&quot; allt är väl upp till betraktarens ögon men jag tycker mig genom uppgiften fått större förståelse för objektorienterad kod i PHP vilket ledde till nuvarande implementation.</p>
        </section>
        <section>
            <h1 id="kmom03">Kmom03</h1>
            <p>
                Nu har jag modellerat kortspelet 21 efter ett flödesdiagram samt psuedo kod. Psuedo kod har jag hört vid namn förut men har inte skrivt egen psuedo kod för ett eget problem eller uppgift. Även om psueodkoden och flödesdiagrammen är ganska korta, så var det en nyttig övning. Det fick mig att tänka igenom övergripande vad jag behövde göra för att implementera mitt spel och det gick sedan lättare att skriva koden då jag redan &quot;tänkt igenom&quot; mycket. Det som var svårast var att försökta följa någon form av standard i hur psuedo koden skulle skrivas.
            </p>
            <p>
                Såhär i kmom03 är jag väldigt nöjd med mitt slutresultat. Jag har skrivit om min kod en hel del från kmom02 och jag tycker nu att jag har en betydligt lättare struktur och kod att följa. Jag har även lagt till röd färg på hjärter och ruter, något som jag fick som ett tips i kmom02. Att implementera det krävde att jag strukturerade om min kod ganska mycket, vilket krävde endel jobb innan jag ens kunde komma igång med uppgiften för kmom03. <br>
                Värt att nämna är att jag i slutändan implementerade en egen, optionell lösning för att stödja &quot;multiplayer&quot;
                läge för kortspelet. Istället för att vara en spelare och spela mot en bank kan jag initiera flera spelare, och genom en
                Queue rotera vilken spelare som har sin tur och i slutändan tävlar alla mot banken. Detta alternativa spel gjorde att
                min psueodkod samt flödesdiagram skiljer sig något.</p>
                <p>
                    För att lösa uppgiften implementerade jag tre klasser, <strong>Player</strong>, <strong>Bank</strong> - som en subklass från Player, samt <strong>GameMaster</strong> som agerar som spelledare. <strong>GameMaster</strong> hanterar alla spelare och för att implementera multiplayer läget implementerade jag en queue, som gjorde att spelarna roterades på rätt sätt. När alla spelare är klara initieras Bank som drar sina kort, och därefter visas resultatet, vem som vann samt respektive spelares kort och poäng. <br>
                    <p>
                        Jag tycker jag har fått till en bra indelning på mina klasser, där metoder tillhör rätt klass och jag har lyckats hålla mina Controllers relativt korta. Näst intill all logik ligger i mina klasser och min Controller hanterar i princip bara get och set i sessionen samt redirects till andra routes.
                    </p>
                    <p>
                    En förbättringspotential hade kunna vara att implementera andra alternativa krav, som att satsa pengar på sina kort eller implementera en mer avancerad Bank. Det kan även finns även lite kod som är rest kod från tidigare kmom som jag inte hunnit rensa bort. Jag hade även velat implementera något interface och trait, nu har jag endast klasser med arv, kompositions eller aggregation relationer. 
                    </p>
                <p>
                    Att arbeta med Symfony känns nu ok, jag behöver egentligen bara skapa klasser och controllers, några inställningar för Symfony vågar jag inte pilla på.
                </p>
                <p>
                    Min TIL är dels psudeo kod och flödesdiagram, att dessa inte bara är &quot;käbbel&quot;utan att de faktiskt underlättar för själva kodandet sen. Kod kan ibland skapa fel för att man har problem med syntax eller annat och man kan fastna på &quot;oviktiga saker&quot; eller avgå lite från första tanken. Men med ett flödesdiagram så har jag nästan en &quot;blue print&quot; på vad jag ska göra vilket gör det lättare att hålla sig till planen. Jag tycker även att jag lärt mig mer om objektorienterad kod och hur jag kan implementera min egen sådan, kmom03 är mycket lättare att följa än kmom02 trots att jag har mycket mer kod.
                </p>
            </p>
        </section>
        <section>
            <h1 id="kmom04">Kmom04</h1>
            <p>
                Nu har jag även lärt mig skriva kod som testar annan kod via PHPunit. Måste säga att det känns riktigt bra när man väl får till det. Det var lite svårt att testa metoder där det fanns beroenden av andra metoder. Men efter att jag lärt mig hur man mockar objekt och metoder så gick det bättre, det är väldigt tillfredsställande när man får till en hög kodtäckning. <br>
                Att kunna skapa snygga rapporter och diagram baserat på testresultaten är ju helt fantastiskt, så enkelt att navigera mellan testerna och det var enkelt att se vilka klasser och metoder som inte blivit testade. Otroligt skönt att enkelt kunna &quot;checka av&quot; en efter en.
            </p>
            <p>
                För mitt kortspel har jag främst två paket, Game och Card. Card innehåller klasserna för att skapa kort enligt en fransk kortlek. Modulen Game innehåller klasser för att kunna köra spelet 21. För Card uppnådde jag en kodteckning på 100% och för Game nådde jag en teckning på 92.42%. Givetvis är inte kodteckningen det primära utan det gäller att ha värdefulla tester, testa metoders return och värde för att säkerställa att man har ett fungerande spel.
            </p>
            <p>
                Till stora delar upplever jag min kod som testbar, framförallt Card var enkel att testa. Det som var svårt var Game vilket kanske är logiskt eftersom det är ett större flöde och sammanhang att testa. Card testar klasserna för kort vilket är fler tester i typen av &quot;hämta värde x&quot; medan Game kräver ett flöde, vilket gör testerna svårare att utföra.
                Delar som jag inte gillar eller känner var särskilt värdefulla var metoder för att visa representationer av en kortlek. Dessa representationer är i princip arrayer med strängar och de kändes därför som mindre värdefulla. Tvärtom gäller för tester när jag måste validera att jag tar emot eller skickar ett objekt som argument. 
            </p>
            <p>
                Jag gjorde en större code-refractoring i kmom03 vilket gjorde att jag nu hade relativt testbar kod. Jag har i kmom03 brutit ner metoder till att göra så få saker som möjligt och det blev därför enklare att testa respektive klasser.
            </p>
            <p>
                Jag tycker att testbar kod visar på snygg och ren kod. Det är då enkelt att följa metoderna och att få en överblick i vad som händer. Att sedan kunna testa och verifiera att metoderna gör det dem ska ger absolut känslan av en bättre kod.
            </p>
            <p>
                Min TIL för detta momen är givetvis PHPunit som verktyg, men en viktigare lärdom är nog just att skriva testbar kod. Detta kommer jag ta med mig i framtiden och jag hoppas på att kunna skriva bättre, renare och mer testbar kod.
            </p>
        </section>
        <section>
            <h1 id="kmom05">Kmom05</h1>
            <p>Nu har vi även testat på Symfony tillsammans med Doctrine. Till en början tyckte jag det var omständigt för det var så många olika kommandon vi gick igenom i övningen. Men väl i uppgiften tyckte jag det gick smidigt, Doctrine gav ju alltid en hint om nästa steg efter ett utfört kommando, och ingenting sparades i databasen innan vi gjort <code>:migrate</code> kommandot vilket också kändes skönt. Jag fick även testa på att uppdatera en Entitet som redan fanns, Doctrine sa direkt ifrån och antog att jag ville lägga till attribut, vilket var precis vad jag ville göra, så det var bara lägga till attribut och köra <code>:migrate</code> igen, riktigt gött!</p>
            
            <p>Angående applikationen Library och dess användargränssnitt så tänkte jag väl egentligen inget speciellt. Vet inte varför gränsnitt är en fråga i detta moment. Men jag tänkte mig att vi skulle ha en överblick över alla böcker. Därifrån kan man välja en bok för att visa mer detaljer, nu visar jag egentligen samma detaljer men med en större bild. Jag hade kunnat lägga till att visa tex en kort beskrivning för varje bok men då behöver jag uppdatera Book entiten igen och lägga till text för varje bok, vilket kändes omständigt. I denna vy la jag även till två knappar, en för att ta bort boken och en annan för att uppdatera boken. Jag tycker det gav ett självförklarande flöde och det kändes logiskt att ha dessa i detaljvyn för en bok.</p>

            <p>
                Att arbeta med CRUD operationer tillsammans med ORM kändes bra, dessa är ju grundläggande SQL operationer och det fanns då färdiga funktioner för varje operation, så det var bara att bygga ett formulär och sedan använda respektive funktion. Det är så skönt också att inte bara få tillbaka data från en databas, utan hela objekt med metoder och annat att använda, och sedan bara skicka tillbaka objektet till databasen för att uppdatera dess tabell.
            </p>
            <p>
                Jag gillar ORM då det låter mig fokusera på applikationen och inte SQL koden för databasen. Kändes skönt att ha färdiga funktioner för grundläggande SQL kommandon. Nu körde jag med Sqlite istället för MariaDb, jag hade gärna provat på MariaDb men pga tidbrist så valde jag den lättare vägen. 
            </p>
            <p>
                Min TIL för detta kmom är främst Doctrine. Jag ägnade lite tid att läsa dokumentationen och undersöka bl.a vad Entiteter och Repositorys var och hur jag kunde ha färdiga metoder som find, findAll osv. Så här efter momentet så känns ju Doctrine riktigt bra. Har även förstått att man kan skapa FormType entiteter i Symfony, som då kan definera ett formulär och dess valideringsregler och sedan använda Doctrine för att koppla fälten till en Entitet i databasen. Måste dock erkänna att det är lite förvirrande för vad som är Symfony funktionalitet och vad som är Doctrines funktionalitet och vart gränsen går.
            </p>
        </section>
        <section>
            <h1 id="kmom06">Kmom06</h1>
            <p>
                PHPmetrics var ett ett bra verktyg för att skapa en sammanfattning eller överblick över koden och bilden jag gillade mest var den som visas under overview, med ringar i olika färger beroende på Cyclomatic Complexity och Maintainability Index. Den visar direkt vilka flaskhalsar som finns, däremot saknar jag interaktivetet som finns i Scrutinizer.
            </p>
            <p>Personligen föredrar jag Scrutinizer då jag faktiskt kan inspektera min kod och få liknande information som i metrics, men här kan jag då även navigera in i en klass och inspektera koden eller tester som validerats. Om jag måste välja hade jag föredragit Scrutizer, att dessutom få schyssta badges att visa upp är ju bra reklam för mitt projekt. På tala om badges så fick jag vid mitt första bygge 10 poäng från Scrutinizer och 23% i coverage. Nu blev coverage så pass lågt då jag inte hade gjort några tester för mina sido controllers, vilket var något jag försökte förbättra men endast lyckades göra lokalt, mina byggen failade och efter x antal försök så gav jag upp. Jag la till tester för en gammal övning <code>App\Dice\Dice</code> och fick då upp coverage till 24%. Det hade varit kul att få högre teckning och jag kommer ta med mig vikten av att skriva tester från början, det kommer nog hjälpa mig att skapa bra classer för routes också vilket borde ge en bättre coverage till nästa gång.</p>
            <p>
                Jag tycker badges kan påvisa kodkvalitét till en viss mån då det ändå ger en stämpel på &quot;bra kod&quot; ungefär som svanenmärkta byggen eller nyckelhålsmärkta produkter också ger en &quot;bra produkt&quot; känsla. Men i slutändan handlar det om koden, eller verktyget används eller inte. Perfekt kod men som inte används känns mindre värd än halvdålig kod men som används överallt.
            </p>
            <p>
                Min TIL för detta moment är främst Scrutnizer, grymt verktyg som vad jag förstår även kan deploya automatiskt vid en push och validerade tester, något som möjliggör CI / CD Pipelines, vilket jag skulle vilja lära mig mer om.
            </p>
        </section>
        <section>
            <h1 id="kmom10">Kmom10</h1>
            <h2>Krav 1-3</h2>
            <p>Jag valde att implementera ett äventyrsspel. Detta då jag redan gjort ett kortspel och då jag själv aldrig spelat något av de övriga alternativen för kortspel så kändes det roligare att få ha en helt egen idé för kmom10.</p>
            <p>
                För att få in ett helt nytt utseende valde jag att använda mig av två olika stylesheets. Detta genom att lägga till en entry i webpack.config.js och sedan byta stylesheet beroende på vilken route som användes.
            </p>
            <p>Min style är vad jag tycker representerar tidiga 90-tals spel, där text och styling är pixlad.</p>
            <p>För att få till själva spellogiken så fick jag fundera ett tag eftersom PHP körs på servern och inte i klienten likt Javascript, så att interagera eventlisteners för knappar och dyligt fick jag tänka bort. Efter att ha tittat på Mikaels video om projektalternativen så fastnade jag lite för att rummen kunde agera som objekt. Därifrån gick det ganska fort till att skapa klasser, jag fick däremot många gånger sätta stopp då jag ville skapa alldeles för många klasser och direkt göra spelet för avancerat. Tanken var att rummen kunde ha objekt som gick att interagera med, och en ryggsäck som spelaren kunde ha som inventory. Spelaren skulle sedan kunna använda sitt inventory för att klara spelet.</p>
            <h2>Krav 4 - Json Api</h2>
            <p>
                Jag hade redan skapat routes med json som svar, för att testa olika interaktioner för spelare, som att lägga till objekt i ryggsäcken osv. Så det var bara att utöka och uppdatera efter spelets uppdatering.
            </p>
            <p>De router jag har kvar nu gör att spelet i princip går att spela men utan någon grafik eller bilder. De router med POST är /equip och /eat som låter användaren equippa ett vapen samt äta ett äpple för att återfå lite hälsa.</p>
            <h2>Krav 5 - ORM</h2>
            <p>
                ORM i mitt fall blev lite omständigt, eftersom jag inte hade någon CRUD i mitt spel så kändes ORM överflödigt. Under spelets gång skapades ändå objekt som sparades i session, så att inkludera en databas blev lite överflödig.
            </p>
            <p>Från början ville jag skapa kopplingstabeller och ha färdiga rum och items, men det rörde bara om min spellogik så jag nöjde mig med att skapa Entiter för alla objekt, och utifrån Entitetern kunna skapa objektinstanser. Skulle jag haft tiden hade jag velat implementera funktionalitet för att skapa entitesobjekt utifrån en Json fil eller liknande. Så att användaren i en Json kan lägga till rum och objekt, och utifrån den skapa Entitetsobjekt. Jag hade även velat skapa olika actions kopplade till objekt, för att kunna spela mer dynamiskt. Nu får jag göra några mindre if kontroller i routerna /action och /item.</p>
            <p>
                Slutresultatet är att jag har en databas med entiteter för Rum, Vapen, Mat och Tools / Items. Utifrån dessa skapar jag objekt och sparar i session. Tycker ändå att utfallet blev bra och spelet är absolut charmigt.
            </p>
            <h2>Krav 6</h2>
            <p>
                Jag har inte implementerat tester för mina Controllers då jag inte fick det att funka på Scrutinzer, jag frågade chatGpt och följde alla möjliga instruktioner men det funkade inte, så jag sket i det. Databasen har jag heller inte implementerat tester för, något som också skulle klassas som krav 6.
            </p>
            <p>
                Där emot tycker jag att jag har gjort ett bra spel och att det är svårare att bygga ett spel fritt istället för att följa ett kortspel, speciellt när vi redan gjort ett kortspel och till stor del hade färdig kod för att fortsätta med en kortspel. Nu fick jag istället tänka om helt från början och skapa allting på nytt.
            </p>
            <p>
                Jag anser att mitt Äventyrsspel visar på en svårare nivå då det är väldigt objekt orienterat och det går enkelt att skapa nya rum, vapen, mat objekt och annat. Logiken är inte hårdkodad utan bygger på de objekt som skapats vid initiering. Jag har även implementerat det så att användaren behöver interagera med vissa objekt för att i slutändan kunna döda draken, detta ger en roligare spelupplevelse, som exempel måste du först equippa en "Shovel" för att genom
                den gräva vid skelettet i Graveyard, när du grävt visas ett nytt objekt som du sedan kan använda för att låsa upp nästa rum - och hitta det magiska äpplet.
            </p>
            <p>
                Jag har även minimalt med spellogik i mina routes och hämtar istället data genom diverse klasser, de routes som innehåller någon form av spellogik är endast /action, /eat och /equip-item.
                
                Jag har även skapat en klass RoomHandler för att hantera alla rumsobjekt, och genom RoomHandler kan jag få fram
                navigering för föregående samt nästa rum, istället för att i samtliga room-templates hårdskriva routes.
                
                Jag har även skapat en klass (DialogHandler) för att hantera dialoger, så att jag genom de interagerade items / objekten kunnat visa ett meddelande kopplat till interaktionen och detta medan jag fortfarande minimerat spellogiken i mina
                templates och routes.
            </p>
            <p>
                För att sammanfatta, jag har inte gjort tester för Controllers eller databas men jag tycker att jag gjort ett snyggt äventyrsspel med bra och effektiv kod, bra struktur och ett genomgående bra upplägg. 
            </p>
            
        </section>
    </div>
        <div class="box2">
            <h3>Förteckning</h3>
            <ul>
                <li><a href="#kmom01">Kmom01</a></li>
                <li><a href="#kmom02">Kmom02</a></li>
                <li><a href="#kmom03">Kmom03</a></li>
                <li><a href="#kmom04">Kmom04</a></li>
                <li><a href="#kmom05">Kmom05</a></li>
                <li><a href="#kmom06">Kmom06</a></li>
                <li><a href="#kmom10">Kmom10</a></li>
            </ul>
        </div>
</div>
</article>
{% endblock %}